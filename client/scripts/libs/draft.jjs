var Backbone = require('backbone'),
    MeModel = require('./models/me'),
    MainView = require('./views/main'),
    TalkyIO = require('talky'),
    SoundEffectManager = require('sound-effect-manager'),
    cookies = require('cookie-getter'),
    tracking = require('tracking'),
    config = require('clientconfig'),
    webrtcSupport = require('webrtcsupport'),
    Router = require('./router');


module.exports = {
    launch: function () {
        window.app = this;
        window.me = new MeModel();

        me.accessToken = cookies('accessToken') || '';
        me.noWebrtc = !webrtcSupport.support;

        // init our api
        this.api = window.api = new TalkyIO({
            token: me.accessToken,
            url: config.apiUrl,
            localVideoEl: 'localVideo',
            remoteVideosEl: null,
            autoRemoveVideos: false,
            log: localStorage.debug,
            peerConnectionConfig: {
                iceServers: []
            },
            peerConnectionConstraints: {
                optional: [
                    {googIPv6: true},
                    {googImprovedWifiBwe: true},
                    {googDscp: true},
                    {googScreencastMinBitrate: 400}
                ]
            },
            adjustPeerVolume: false
        });
        if (webrtcSupport.prefix === 'webkit') {
            // chrome specific GUM tweaks
            this.api.config.media = {
                audio: {
                    optional: [
                        //{googDucking:false},
                        {googEchoCancellation: true},
                        {googAutoGainControl: true},
                        {googNoiseSupression: true},
                        {googHighpassFilter: true},
                        {googAudioMirroring: false},
                        {googNoisesuppression2: true},
                        {googEchoCancellation2: true},
                        {googAutoGainControl2: true},
                        {chromeRenderToAssociatedSink: true}
                    ]
                },
                video: {
                    optional: [
                        {googLeakyBucket: true},
                        {googNoiseReduction: false} // workaround for chrome 37, see https://code.google.com/p/webrtc/issues/detail?id=3807#c10
                    ]
                }
            };
        }

        this.api.on('user', function (user) {
            me.set(user);
            tracking.identify(me);
        });

        // when it's ready set a state flag
        this.api.on('readyToCall', function () {
            tracking.track('readyToCall');
            me.readyToCall = true;
        });

        // handle cases where password is required
        this.api.on('passwordRequired', function () {
            me.enterPasswordDialog = true;
        });

        // handle locking/unlocking
        this.api.on('locked', function (key) {
            me.roomKey = key;
        });
        this.api.on('unlocked', function () {
            me.roomKey = '';
        });

        this.view = new MainView({
            model: me,
            el: document.body
        }).render();

        new Router();
        app.history = Backbone.history;
        // we have what we need, we can now start our router and show the appropriate page
        app.history.start({pushState: true, root: '/'});

        // play some sounds when people come and go
        app.sounds = new SoundEffectManager();
        app.sounds.loadFile('/sounds/online.mp3', 'online');
        app.sounds.loadFile('/sounds/offline.mp3', 'offline');

        tracking.track('webAppLoaded');
        tracking.gosquared();
    },
    navigate: function (page) {
        var url = (page.charAt(0) === '/') ? page.slice(1) : page;
        app.history.navigate(url, true);
    },
    renderPage: function (view, animation) {
        var container = $('#pages');

        if (app.currentPage) {
            app.currentPage.hide(animation);
        }
        // we call render, but if animation is none, we want to tell the view
        // to start with the active class already before appending to DOM.
        container.append(view.render(animation === 'none').el);
        view.show(animation);
    },
    saveRoomDescriptions: function (details) {
        me.roomKey = details.key;
        me.roomIsReserved = details.reserved;
    },
    join: function (name) {
        app.api.joinRoom(name, function (err, roomInfo) {
            if (!err) {
                app.saveRoomDescriptions(roomInfo);
                app.dump('joined room');
            }
        });
    },
    login: function () {
        window.location = '/auth?next=' + window.location.href;
        return false;
    },
    logout: function () {
        window.location = '/logout';
        return false;
    },
    dump: function (str) {
        if (localStorage.debug === 'true') {
            if (typeof(window.dump) === 'function') {
                window.dump(str + '\n');
            } else {
                console.log(str);
            }
        }
    }
};

$(function () {
    module.exports.launch();
});
